---
layout: post
title: CVE-2022-41674 LPE
description: This is a collection of short CSS snippets I thought might be useful for beginners
summary: This is a collection of short CSS snippets I thought might be useful for beginners.
tags: ndays
---
## Preface

Since this is my 1st nday, I wanted to gather as much information from modern-ish linux kernel exploits and try to systematize them in a way that would pave a good path towards progressive improvement. The links for them are under the references section. 

In this post, I'll be talking about exploiting CVE-2022-41674, one of the vulnerabilities found in the mac802.11 stack in late 2022. 
The discover was very friendly, providing poc code to trigger the vulnerability. Reading the crash report and previous patches, it seemed like a good task to practice exploit writing on. The first thing I needed to understand was how we can control the data that gets passed in the malformed beacon frames, which led me to dive into how beacon frames work. I'll summarize what I learned below. 

## Beacon Frames

A beacon frame is a frame that gets sent out when a device needs to be discovered by other devices. 
- Beacon frames have the following format at the beginning:
    - Frame Control Field: 2 bytes
    - Duration/ID: 1 byte
    - Receiver address: xx:xx:xx:xx:xx:xx
    - Destination address: xx:xx:xx:xx:xx:xx
    - Transmitter address: xx:xx:xx:xx:xx:xx
    - Source address: xx:xx:xx:xx:xx:xx
    - BSS Id: xx:xx:xx:xx:xx:xx
    - STA address: xx:xx:xx:xx:xx:xx
    - Data

As I was messing around with the beacon frames and debugging it in the linux kernel, I figured that I could control the size and data of the frames, which helped a lot. If you modify this byte in the "Data" section of the beacon frame, it controls how much data will get memcpy'd in here: <show source>

## Vulnerability

The vulnerability is an integer overflow which led to a heap overflow. More specifically, it originates when doing a update for beacon frames. The code looks like this

In order to trigger the vulnerability, the victim would run a wireless scan and an attacker would send pcaps containing malformed beacon frames. I tested this locally and just did an LPE, not remote LPE or RCE. 


## Exploit Strategy

Since we can control how much data we send, this means we can target a specific slab cache for our heap overflow. I chose to use kmalloc-96 because we can use subprocess_info objects for our KASLR bypass. 

Get write primitive by sending a second packet, modified to contain our modprobe_path address. We spray to overwrite a msg_msg freelist pointer and then when we allocate msg_msg again, we can overwrite modprobe_path using the data in msg.mtext field, giving us a root shell. 

## OOB Read

Since we control what kmalloc cache we want to target, we revise our pcap payload to target the kmalloc-96 cache. 
- msg_msg's m_ts field is an attractive target that we can overwrite. A popular technique is overwriting this field and then calling recvmsg() with the MSG_COPY flag. Specifying the MSG_COPY flag does not unlink the msg but rather just copies the data out for us.
- Spray subprocess_info objects in the kmalloc-96 cache using  `socket(22, AF_INET, 0);`. This is so we can get our call_usermodehelper_work leak which will give us a way to bypass KASLR
- Now that we bypassed KASLR, we can calculate the right addresses for the classic modprobe_path technique.
- `CONFIG_USERMODE_STATIC_HELPER`,`CONFIG_FREELIST_RANDOMIZATION`, and `CONFIG_FREELIST_HARDENED` aren't on. Having these on would make our exploit harder and we'd have to resort to other methods. But as a first poc I wanted to get it through without these on. 

## Freelist Poisoning

Groom the kmalloc-128 heap with msg_msg objects and then spray modprobe_path address at designated locations where the freelist pointer might be. From here allocate kmalloc-128 msg_msg objects and overwrite modprobe_path with user defined binary. Trigger modprobe_path by executing a file with an invalid format, which causes modprobe to look for /sbin/modprobe path which was overwritten with the evil binary. Get root shell

## Demo

- Full poc on github

## Takeaways and improvements

Exploit reliability needs to be improved. The heap grooming stage could probably be improved as well and stabilizing the primitives could also be improved. I might come back to this and add on more mitigations like freelist hardening and randmoization just to play around. 